package elastic:tls@0.1.0;

/// TLS error types that can occur during operations
interface types {
    /// Error variants that can occur during TLS operations
    variant tls-error {
        /// Invalid or malformed certificate
        invalid-certificate(string),
        /// Invalid or malformed private key
        invalid-key(string),
        /// Connection establishment failed
        connection-failed(string),
        /// TLS handshake failed
        handshake-failed(string),
        /// Failed to write data
        write-failed(string),
        /// Failed to read data
        read-failed(string),
        /// Unsupported TLS protocol version
        unsupported-protocol(string),
        /// Unsupported cipher suite
        unsupported-cipher(string),
    }

    /// Supported TLS protocol versions
    enum tls-version {
        /// TLS 1.2
        tls-1-2,
        /// TLS 1.3
        tls-1-3,
    }

    /// Supported cipher suites
    enum cipher-suite {
        /// AES-128-GCM with SHA-256
        tls-aes-128-gcm-sha256,
        /// AES-256-GCM with SHA-384
        tls-aes-256-gcm-sha384,
        /// ChaCha20-Poly1305 with SHA-256
        tls-chacha20-poly1305-sha256,
    }

    /// TLS configuration options
    record tls-config {
        /// TLS protocol version to use
        version: tls-version,
        /// List of cipher suites to support
        cipher-suites: list<cipher-suite>,
        /// Whether to verify peer certificates
        verify-peer: bool,
        /// Whether to verify hostname
        verify-hostname: bool,
    }
}

/// TLS interface for secure communication
interface tls {
    use types.{tls-error, tls-version, cipher-suite, tls-config};

    /// Create a new TLS context with the given configuration
    create-context: func(config: tls-config) -> result<u32, tls-error>;
    
    /// Destroy a TLS context and free its resources
    destroy-context: func(handle: u32) -> result<_, tls-error>;

    /// Load a certificate into the TLS context
    load-certificate: func(handle: u32, cert: list<u8>) -> result<_, tls-error>;
    
    /// Load a private key into the TLS context
    load-private-key: func(handle: u32, key: list<u8>) -> result<_, tls-error>;
    
    /// Load CA certificates for peer verification
    load-ca-certificates: func(handle: u32, certs: list<u8>) -> result<_, tls-error>;

    /// Connect to a remote TLS server
    connect: func(handle: u32, hostname: string, port: u16) -> result<u32, tls-error>;
    
    /// Accept incoming TLS connections on a port
    accept: func(handle: u32, port: u16) -> result<u32, tls-error>;
    
    /// Close a TLS connection
    close: func(conn: u32) -> result<_, tls-error>;

    /// Write data over a TLS connection
    write: func(conn: u32, data: list<u8>) -> result<u32, tls-error>;
    
    /// Read data from a TLS connection
    read: func(conn: u32, max-size: u32) -> result<list<u8>, tls-error>;

    /// Get the peer's certificate
    get-peer-certificate: func(conn: u32) -> result<list<u8>, tls-error>;
    
    /// Get the negotiated TLS protocol version
    get-protocol-version: func(conn: u32) -> result<tls-version, tls-error>;
    
    /// Get the negotiated cipher suite
    get-cipher-suite: func(conn: u32) -> result<cipher-suite, tls-error>;
}

/// TLS implementation world
world tls-impl {
    export tls;
} 